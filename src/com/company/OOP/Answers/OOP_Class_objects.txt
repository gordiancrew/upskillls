1.Q:Дайте развернутое объяснение трем концепциям ООП.
1.A:1)Инкапсуляция
    Инкапсуляция выступает договором для объекта, что он должен скрыть, а что открыть для доступа другими объектами.
    В JAVA мы используем модификатор доступа private для того, чтобы скрыть метод и ограничить доступ к переменной
    из внешнего мира. JAVA также располагает различными модификаторами доступа: public, по умолчанию, protected,
    private, которые используются для ограничения видимости на разных уровнях. Но конечной целью является инкапсуляция
    тех вещей, которые не должны быть изменены. Лучше всего работает подход, при котором, у класса  должна быть
    только одна причина для изменения, и инкапсулирование воплощает в реальность проектирование этой “одной причины”.
    Правильным в инкапсуляции считается сокрытие часто изменяющихся вещей во избежание повреждения других классов.
    2)Полиморфизм
    Полиморфизм в программировании — это способность предоставлять один и тот же интерфейс для различных базовых форм
    (типов данных). Это означает, что классы, имеющие различную функциональность, совместно используют один и тот же
    интерфейс и могут быть динамически вызваны передачей параметров по ссылке.
    Красота полиморфизма заключается в том, что код, работая с различными классами, не должен знать, какой класс
    он использует, так как все они работают по одному принципу. Процесс, применяемый объектно-ориентированными
    языками программирования для реализации динамического полиморфизма, называется динамическим связыванием.
    Примечание: Полиморфизм — это способность выбирать более конкретные методы для исполнения в зависимости от объекта.
    Полиморфизм осуществляется тогда, когда не задействованы абстракные классы.
    3)Наследование
     Наследование — это включение поведения (т.е. методов) и состояния (т.е. переменных) базового класса в
     производный класс, таким образом они становятся доступны в этом производном классе. Главное преимущество
     наследования в том, что оно обеспечивает формальный механизм повторного использования кода и
     избегает дублирования.
     Унаследованный класс расширяет функциональность приложения благодаря копированию поведения родительского класса
     и добавлению новых функций. Это делает код сильно связанным. Если вы захотите изменить суперкласс, вам придется
     знать все детали подклассов, чтобы не разрушить код.
     Наследование — это форма повторного использования программного обеспечения, когда из уже существующего
     класса (суперкласса) создается новый класс (подкласс), который расширяет свою функциональность и при этом
     использует некоторые свойства суперкласса.
     Так что, если у вас есть класс-родитель, а потом появляется класс-наследник, то наследник наследует все вещи,
     которыми обладает родитель.
     4)Абстракция
     Абстракция означает разработку классов исходя из их интерфейсов и функциональности, не принимая во внимание
     реализацию деталей. Абстрактный класс представляет собой интерфейсы без включения фактической реализации.
     Он отличает реализацию объекта от его поведения. Абстракция упрощает код, скрывая несущественные детали.

2.Q:Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса,
    а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию?
    Где еще в классе полям могут быть присвоены начальные значения?
  A:В Java поля (fields) могут принадлежать классу или объекту. Поля, принадлежащие классу,
    являются статическими, а поля, принадлежащие объекту, - нестатическими.
    Статические поля доступны без создания объекта класса. Соответственно инициализироваться статические и
    нестатические поля должны в разное время: одни до создания объекта класса, а другие после. Если поле объявлено,
    но не проинициализировано то компилятор выдаст ошибку.
    Существуют следующие методы инициализации полей:
    -Инициализация в месте объявления поля(поля класса, поля объекта):Применяется, если инициализация может быть
     произведена коротким выражением и доступен контекст, необходимый для ее проведения.
    -Инициализационный блок(поля класса, поля объекта):Применяется, если инициализационный код неудобно записывать
     одним выражением или же, например, нужна обработка проверяемых исключений. В случае объектов может применяться
     для инициализации полей объектов анонимных классов.
    -Конструктор класса:Применяется, если для инициализации нужны параметры конструктора.

3.Q:Приведите правила, которым должен следовать компонент java-bean.
   -Класс должен иметь конструктор без параметров, с модификатором доступа public. Такой конструктор позволяет
   инструментам создать объект без дополнительных сложностей с параметрами.
   -Свойства класса должны быть доступны через get, set и другие методы (так называемые методы доступа),
   которые должны подчиняться стандартному соглашению об именах. Это легко позволяет инструментам автоматически
   определять и обновлять содержание bean’ов. Многие инструменты даже имеют специализированные редакторы для различных
   типов свойств.
   -Класс должен быть сериализуем. Это даёт возможность надёжно сохранять, хранить и восстанавливать состояние bean
   независимым от платформы и виртуальной машины способом.
   -Класс должен иметь переопределенные методы equals(), hashCode() и toString().

4.Q:Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов?
    Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены?
    Можно ли перегрузить методы в базовом и производном классах? Можно ли private метод базового класса
    перегрузить public методов производного? Можно ли перегрузить конструкторы, и можно ли при перегрузке
    конструкторов менять атрибуты доступа у конструкторов?
A:В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров.
    Такой механизм называется перегрузкой методов (method overloading).
    Перегрузка методов удобна тем, что один и тот же метод можно использовать с разным количеством параметров и типом.
    В производном классе разрешается перегружать любые видимые методы. Перегрузка методов в базовом классе так же
    разрешена. Private метод базового класса нельзя перегрузить в public методе производного.
    Конструкторы перегружать можно. Атрибуты доступа при перегрузке менять можно.

5.Q:Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание?
  Объясните правила, которым следует компилятор при разрешении перегрузки;
  в том числе, если методы перегружаются примитивными типами, между которыми возможно неявное приведение или
  ссылочными типами, состоящими в иерархической связи.
A: Связывание означает наличие связи между ссылкой и кодом. Например, переменная, на которую вы ссылаетесь,
    привязана к коду, в котором она определена. Аналогично, вызываемый метод привязан к месту в коде, где он определен.
    Существует два типа связывания методов в языке Java: ранее связывание (его ещё называют статическим) и
    позднее (соответственно, динамическое) связывание. Вызов метода в Java означает, что этот метод привязывается к
    конкретному коду или в момент компиляции, или во время выполнения, при запуске программы и создании объектов.
     Фундаментальное различие между статическим и динамическим связыванием в Java состоит в том,
     что первое происходит рано, во время компиляции на основе типа ссылочной переменной, а второе – позднее,
     во время выполнения, с использованием конкретных объектов.
     Перегрузка метода это раннее связывание.
    При перегрузке метода примитивными типами целые числа диапазона int будут восприниматься компилятором как int, а не
    shot или byte. вещественные типы будут восприниматься как double. Для выполнения программы эти типы нужно приводить
    явно. в процессе определения метода, который нужно вызвать, типы могут только расширяться, но не сужаться.


6.Q:Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует,
    а в каких – нет, и почему?
 A:ключевое слово this требуется для того, чтобы метод мог сослаться на вызвавший его объект.
    Применяется слово this  в двух случаях:
    -Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена;
    -Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого.
     Это еще называется явным вызовом конструктора.
    This не применяется в статических методахБ так как не на что ссылаться.

7.Q:Что такое финальные поля, какие поля можно объявить со спецификатором final?
    Где можно инициализировать финальные поля?
 A:Модификатор final делает дальнейшее изменение объекта невозможным.
    Final применяется для классов, полей и методов.
    При инициализации final полей, дальше менять значение переменных нельзя. При этом не обязательно сразу
    задавать значение переменной, неизменным будет первое заданное значение. Final переменные это
    константы и именуются заглавными буквами.Инициализировать константы можно сразу при объявлении, в конструкторе,
    в блоке инициализации, в статическом блоке.

8.Q:Что такое статические поля, статические финальные поля и статические методы.
    К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы?
    Наследуются ли статические методы?
 A:Static — модификатор, применяемый к полю, блоку, методу или внутреннему классу. Данный модификатор указывает
    на  привязку субъекта  к текущему классу.При обозначении переменной уровня класса мы указываем на то, что это
    значение относится к классу. Если этого не делать, то значение переменной будет привязываться к объекту,
    созданному по этому классу. При объявлении статических переменных ставится модификатор static.
    Статические финальные поля это неизменные поля, принадлежащие данному классу.
    Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту.
    Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам.
    Статические методы не подлежат переопределению в классах-потомках. Во время наследования происходит перекрытие
    родительского статического метода другим методом, который описан в классе-потомке.
    Перегружаться статические методы могут.
    Статические методы могут наследоваться.

9.Q:Что такое логические и статические блоки инициализации? Сколько их может быть в классе,
    в каком порядке они могут быть размещены и в каком порядке вызываются?
  A:При описании класса могут быть использованы логические блоки. Логическим блоком называется код,
    заключенный в фигурные скобки и не принадлежащий ни одному методу текущего класса, например:
     { /* код */ }
    static { /* код */ }
    есть два типа блоков  - статический и нестатический;
    Логические блоки чаще всего используются в качестве инициализаторов полей, но могут содержать вызовы методов и
    обращения к полям текущего класса. При создании объекта класса они вызываются последовательно, в порядке размещения,
    вместе с инициализацией полей как простая последовательность операторов, и только после выполнения
    последнего блока будет вызван конструктор класса. Операции с полями класса внутри логического
    блока до явного объявления этого поля возможны только при использовании ссылки this, представляющую
    собой ссылку на текущий объект.
    Логический блок может быть объявлен со спецификатором static. В этом случае он вызывается только один
    раз в жизненном цикле приложения при создании объекта или при обращении к статическому методу (полю) данного класса.

10Q:Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы
    и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода,
    при использовании перегрузки для методов с переменным числом параметров?
  A:Методы, способные принимать переменное количество аргументов  называют методами с переменным числом аргументов
    (другое название - методы переменной арности).
    В методах этого типа список параметров имеет не фиксированную, а переменную длину,
    что обеспечивает дополнительную гибкость, позволяя методам принимать произвольное число аргументов.
    Синтаксис переменного числа параметров обозначается при помощи типа переменной+ знак троеточие(...)+
    имя. например(String...v).В параметрах метода могут быть и другие типы входящего значения.
    Список параметров переменной длины всегда в аргументах метода указывается последним. Список параметров
    переменной длины в аргументах метода может применятся один раз.

11Q:Чем является класс Object? Перечислите известные вам методы класса  Object, укажите их назначение.
  A:В Java есть специальный суперкласс Object и все классы являются его подклассами. Поэтому ссылочная переменная
    класса Object может ссылаться на объект любого другого класса. Так как массивы являются тоже классами,
    то переменная класса Object может ссылаться и на любой массив.
    У класса есть несколько важных методов:
    Object clone() - создаёт новый объект, не отличающий от клонируемого
    boolean equals(Object obj) - определяет, равен ли один объект другому
    void finalize() - вызывается перед удалением неиспользуемого объекта
    Class<?> getClass() - получает класс объекта во время выполнения
    int hashCode() - возвращает хеш-код, связанный с вызывающим объектом
    void notify() - возобновляет выполнение потока, который ожидает вызывающего объекта
    void notifyAll() - возобновляет выполнение всех потоков, которые ожидают вызывающего объекта
    String toString() - возвращает строку, описывающий объект
    void wait() - ожидает другого потока выполнения
    void wait(long millis) - ожидает другого потока выполнения
    void wait(long millis, int nanos) - ожидает другого потока выполнения
    Методы getClass(), notify(), notifyAll(), wait() являются финальными и их нельзя переопределять.

12Q:Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?
  A:Хэш-функция, которая представлена в Java  методом hashCode(), возвращает числовое значение фиксированной
     длины для любого объекта. В случае с Java метод hashCode() возвращает для любого объекта 32-битное число типа int.
     Ситуация в которой два разных объекта генерируют одинаковый хэш-код называется коллизией и возможна из за
     ограничения диапазона значений хэш, и невозможности создать  алгоритма для обсолютной уникальности возвращаемого
     значения.

13Q:Как вы думаете, для чего используется наследование классов в java-программе? Приведите пример наследования.
    Как вы думаете, поля и методы, помеченными модификатором доступа private, наследуются?
   A:Наследование — это форма повторного использования программного обеспечения, когда из уже существующего
     класса (суперкласса) создается новый класс (подкласс), который расширяет свою функциональность и при этом
     использует некоторые свойства суперкласса.
     Так что, если у вас есть класс-родитель, а потом появляется класс-наследник, то наследник наследует все вещи,
     которыми обладает родитель.
     Например у нас есть класс Cat с переменными name и int мы можем от этого класса образовать производные классы
     по породе котов с присутствующими только данной породе характеристикам.
     Пример:
     public class Cat{
      private String  name;
         private int age;
          public  Cat(String name, int age){
             this.name=name;
             this.age=age;
         }

         public String getName() {
             return name;
         }

         public void sayMay(){
             System.out.println("Cat "+name+" say may");
         }
     }
     Класс наследник:
public class Oriental extends Cat {

        private int longer;
        private String may;
    {
       may="Hello kitten" ;
    }

    public Oriental(String name, int age, int longer) {
        super(name, age);
        this.longer=longer;
    }

    @Override
    public void  sayMay(){
        System.out.println("Cat "+getName()+" say "+may);

    }

}

  поля и методы помеченный модификатором private не наследуются.


14Q:Укажите, как вызываются конструкторы при создании объекта производного класса?
    Что в конструкторе класса делает оператор super()? Возможно ли в одном конструкторе использовать
    операторы super() и this()?
  A:При создании объекта производного класса конструкторы вызываются по порядку в соответствии с иерархией:
    т.е. сразу вызывается конструктор базового класса, затем конструктор производного от него класса и т.д.
    Ключевое слово super в Java используется тогда, когда подклассу требуется сослаться на его непосредственный
    супер класс.
    У ключевого слова super имеются две общие формы:
    -Для вызова конструктора супер класса:
    super(списокАргументов);
    -Для обращения к члену супер класса, скрываемому членом подкласса:
    suреr.member;
    Использовать операторы this() и super() в одном конструкторе использовать нельзя

15Q:Объясните, как вы понимаете утверждения: “ссылка базового класса может ссылаться на объекты своих
    производных типов” и “объект производного класса может быть использован везде, где ожидается объект его
    базового типа”. Верно ли обратное и почему?
  A:Наследование и возможность переопределения методов открывают нам большие возможности.
    Прежде всего мы можем передать переменной суперкласса ссылку на объект подкласса:
    Напроимер класс B производный от класса A, создаеим объект базового класса со ссылкой на производный
    A a=new B(); объект a будет обладать свойствами и методами класса B, но при этом он не перестал относится к классу A,
    но в методах он будет представлен той  версией , которая определена в классе B, а не в A.
    Обратное в java не верно. Потому что в производных классах расширяются характеристики базового и обратно сужаться не
    могут.

16Q:Что такое переопределение методов? Как вы думаете, зачем они нужны?
    Можно ли менять возвращаемый тип при переопределении методов? Можно ли менять атрибуты доступа при
    переопределении методов? Можно ли переопределить методы в рамках одного класса?
  A:Переопределение метода это переписывание метода производного класса , который существует в базовом классе.
    Переопределение нужно что бы оптимизировать метод базового класса под характеристики и свойства производного.
    Менять возвращающий тип значения нельзя. класс наследник может расширить видимость protected метода до public.
    Сузить видимость класс наследник не может.
    В рамках одного класса переопределять методы нельзя.

17Q:Определите правило вызова переопределенных методов.
    Можно ли статические методы переопределить нестатическими и наоборот?
  A:В языке программирования Java, когда подкласс содержит метод, переопределяющий метод суперкласса,
    то он может помимо своего метода вызывать и метод суперкласса при помощи ключевого слова super
    Статические методы нельзя переопределить нестатическими и наоборот.

18Q:Какие свойства имеют финальные методы и финальные классы? Как вы думаете, зачем их использовать?
  A:Обозначая метод класса модификатором final, мы имеем ввиду, что ни один производный класс не в состоянии
    переопределить этот метод, изменив его внутреннюю реализацию. Другими словами, речь идет о финальной версии метода.
    Класс, помеченный как final, не поддается наследованию и все его методы косвенным образом приобретают свойство final.
    В большинстве случаев final используется для обеспечения безопасности методов и классов.

19Q:Укажите правила приведения типов при наследовании. Напишите примеры явного и неявного преобразования
    ссылочных типов. Объясните, какие ошибки могут возникать при явном преобразовании ссылочных типов.
  A:При приведении ссылочных типов при наследовании по иерархии наследования существует 2 варианта привидения:
    1) Восходящее преобразование(upcasting) преобразование типа от подкласса внизу к базовому типу вверху.
    Такое преобразование выполняется автоматически.
    2) Низходящее преобразование (downcasting) преобразование типа от базового типа вниз к подклассу. Такое преобразование
    не всегда верно, поэтому автоматически оно не происходит, его надо задавать явно , указав необходимый тип
    в скобках, по аналогии явного преобразования. Желательно перед этим проверить обьект является ли он производным
    от типа к которому приводится, так как обьект базового класса не всегда является обьектом принадлежащим его
    производному классу и возникнит ошибка RuntimeException.
    public class Main {
        public static void main(String[] args) {
            B b2 = new B("start");
            A a = b2;
            B b = (B) a;
            b.print();
        }
    }
    В данном примере  обьект b2 по восходящему преобразованию приводится к обьекту класса A переменной а.
    Обьект а явно приводится к переменной b класса B.

20Q:Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного
    значения с Type.class отличается от использования оператора instanceof?
  A:объекты класса Class это классы и интерфейсы.
    Оператор instanceof возращает булеан значение был ли обьект класса на который ссылается данная переменная
    создан на основе проверяемого класса, а getClass являются ли объекты принадлежащими одному классу.

21Q:Укажите правила переопределения методов equals(), hashCode() и toString().
  A:Java предлагает следующие правила для переопределения этих методов:
    1)Рефлексивность: Объект должен равняться себе самому.
    2)Симметричность: если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.
    3)Транзитивность: если a.equals(b) возвращает true и b.equals(c) тоже возвращает true, то c.equals(a)
      тоже должен возвращать true.
    4)Согласованность: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор,
      пока какое-либо значение свойств объекта не будет изменено. То есть, если два объекта равны в Java,
      то они будут равны пока их свойства остаются неизменными.
    5)Сравнение null: объект должны быть проверен на null. Если объект равен null, то метод должен вернуть false,
      а не NullPointerException. Например, a.equals(null) должен вернуть false.
     Соглашение между equals и hashCode в Java
    1)Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.
    2)Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми,
      так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.
    Для переопределения метода toString():
    1)Используйте StringBuilder для составления вывода toString()
    2)Использование аннотации @Override
    3)Печать содержимого массива, вместо вывода объекта массива

22Q:Что такое абстрактные классы и методы? Зачем они нужны? Бывают ли случаи, когда абстрактные методы содержат тело?
    Можно ли в абстрактных классах определять конструкторы? Могут ли абстрактные классы содержать неабстрактные методы?
    Можно ли от абстрактных классов создавать объекты и почему?
  A:Класс, который во время объявления содержит в себе ключевое слово abstract, известен как абстрактный класс.
    -Абстрактные классы в Java могут содержать или не содержать абстрактные методы,
     т.е. методы без тела (public void get();)
    -Если класс имеет хотя бы один абстрактный метод, то класс должен быть объявлен абстрактным.
    -Если класс объявлен абстрактным, его нельзя реализовать.
    -Чтобы использовать абстрактный класс, вам нужно наследовать его из другого класса,
     обеспечить реализацию абстрактных методов в нём.
    -Если вы наследуете абстрактный класс в Java, вам нужно обеспечить реализацию всех абстрактных методов в нём.
    Абстрактный метод:
    Если вы хотите, чтобы класс содержал конкретный метод, но вы желаете, чтобы фактическая реализация этого
     метода определялась дочерними классами, вы можете объявить метод в родительском классе как абстрактный
    -Ключевое слово abstract используется для объявления метода абстрактным.
    -Вам нужно разместить ключевое слово abstract перед именем метода во время его объявления.
    -Абстрактный метод в Java содержит сигнатуру метода, но не содержит тела метода.
    -Вместо фигурных скобок у абстрактного метода будет точка с запятой (;) на конце.
    Абстрактные классы и методы в Java необходимы для осуществления принципа абстракции-одного из ключевого
    принципа ООП.
    Абстракный метод тела иметь не может.
    Абстракные классы могут содержать неабстракные методы.
    Объекты от абстракных классов создавать нельзя, потому что методы класса не реализуются в данном классе.


23Q:Что такое интерфейсы? Как определить и реализовать интерфейс в java-программе?
    Укажите спецификаторы, которые приобретают методы и поля, определенные в интерфейсе.
    Можно ли описывать в интерфейсе конструкторы и создавать объекты? Можно ли создавать интерфейсные ссылки и если да,
    то на какие объекты они могут ссылаться?
  A:Интерфейс — это ссылочный тип в Java. Он схож с классом. Это совокупность абстрактных методов.
    Класс реализует интерфейс, таким образом наследуя абстрактные методы интерфейса.
    Что бы определить интерфейс используется ключевое слово interface. Например:
    interface A{
    void go();
    }
    Чтобы класс применил интерфейс используется ключевое слово implements.:
    class B implements A{
    public void go(){
    System.out.print("go");
     }
    }
    Все методы интерфейса не имеют модификаторов доступа, но фактически по умолчанию доступ public,
    так как цель интерфейса - определение функционала для реализации его классом.
    Поэтому весь функционал должен быть открыт для реализации.Методы являются abstract.
     В JDK 8 была добавлена такая функциональность как методы по умолчанию. И теперь интерфейсы кроме определения
     методов могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс,
     не реализует метод.
     Метод по умолчанию - это обычный метод без модификаторов, который помечается ключевым словом default.
     Затем  нам необязательно этот метод реализовать, хотя мы можем его и переопределить.
     Переменные в интерфейсах по умолчанию являются public static final.
     Начиная с JDK 8 в интерфейсах доступны статические методы - они аналогичны методам класса.
     Чтобы обратиться к статическому методу интерфейса также, как и в случае с классами, пишут название интерфейса и метод.
     По умолчанию все методы в интерфейсе фактически имеют модификатор public. Однако начиная с Java 9 мы также можем
     определять в интерфейсе методы с модификатором private. Они могут быть статическими и нестатическими, но они не
     могут иметь реализации по умолчанию.
     Подобные методы могут использоваться только внутри самого интерфейса, в котором они определены.
     То есть к примеру нам надо выполнять в интерфейсе некоторые повторяющиеся действия,
     и в этом случае такие действия можно выделить в приватные методы:
     Объекты в интерфейсе создавать нельзя
     Как и в случае с классами, интерфейсы могут использоваться в качестве типа параметров метода или в качестве
     возвращаемого типа.

24Q:Для чего служит интерфейс Clonable? Как правильно переопределить метод clone() класса Object,
    для того, что объект мог создавать свои адекватные копии?
  A:У объекта java.lang.Object есть метод protected Object clone() throws CloneNotSupportedException.
    Этот метод позволяет создавать копии объектов. Он бросает исключение CloneNotSupportedException для всех объектов,
    которые не реализуют интерфейс java.lang.Cloneable,  а для классов, реализующих этот интерфейс,
    возвращает копию объекта, которая создана копированием всех полей исходного объекта.
    Содержимое полей не копируется. Если поле является ссылочным, то оно будет указывать на тот же самый объект,
    что и исходное поле.
    При переопределении метода clone() необходимо что б класс объекта реализовывал интерфейс clonable.
    Можно вызвать базовую реализацию метода clone()
    class Point implements Cloneable
    {
     int x;
     int y;

     public Object clone()
     {
      return super.clone();
     }
    }
    либо прописать реализацию метода вручную:
    class Point
    {
     int x;
     int y;

     public Object clone()
     {
      Point point = new Point();
      point.x = this.x;
      point.y = this.y;
      return point;
     }
    }


25Q:Для чего служат интерфейсы Comparable и Comparator? В каких случаях предпочтительнее использовать первый,
    а когда – второй? Как их реализовать и использовать?
 A:Два новых интерфейса java.lang.Comparable и java.util.Comparator были добавлены в версии Java 5.
   Использование данных интерфейcов в своих приложениях позволяет упорядочивать (сортировать) данные.
   В интерфейсе Comparable объявлен только один метод compareTo (Object obj),
   предназначенный для упорядочивания объектов класса. Данный метод удобно использовать для сортировки списков
   или массивов объектов.
   Метод compareTo (Object obj) сравнивает вызываемый объект с obj. В отличие от метода equals, который возвращает
   true или false, compareTo возвращает:
   0, если значения равны;
   Отрицательное значение (обычно -1), если вызываемый объект меньше obj;
   Положительное значение (обычно +1), если вызываемый объект больше obj.
   Если типы объектов не совместимы при сравнении, то compareTo (Object obj) может вызвать исключение ClassCastException.
   Необходимо помнить, что аргумент метода compareTo имеет тип сравниваемого объекта класса.
   Обычные классы Byte, Short, Integer, Long, Double, Float, Character, String уже реализуют интерфейс Comparable.

   В интерфейсе Comparator объявлен метод compare (Object obj1, Object obj2),
   который позволяет сравнивать между собой два объекта. На выходе метод возвращает значение 0, если объекты равны,
   положительное значение или отрицательное значение, если объекты не тождественны.
   Метод может вызвать исключение ClassCastException, если типы объектов не совместимы при сравнении.

   Отличие интерфейсов Comparator и Comparable
   Интерфейс Comparable используется только для сравнения объектов класса, в котором данный интерфейс реализован.
   Т.е. interface Comparable определяет логику сравнения объекта определенного ссылочного типа внутри своей
   реализации (по правилам разработчика).
   Comparator представляет отдельную реализацию и ее можно использовать многократно и с различными классами.
   Т.е. interface Comparator позволяет создавать объекты, которые будут управлять процессом сравнения
   (например при сортировках).