1)Q:Дайте определение массиву. Как осуществляется индексация элементов массива.
   Как необходимо обращаться к i-му элементу массива?
 A:Массив — это структура данных, в которой хранятся элементы одного типа.
   Индексация массива начинается по порядку, первая "ячейка" со значением имеет индекс -0, далее 1, 2, 3 и т.д.
   Для получения данных определенной ячейки массива под индексом "i",необходимо после  указать после
   имени массива его индекс в квадратных скобках.

2)Q:Приведите способы объявления и инициализации одномерных и двумерных массивов примитивных и ссылочных типов.
   Укажите разницу, между массивами примитивных и ссылочных типов.
 A:Массив, как и любую переменную в java, необходимо объявить. Объявить его можно двумя способами:
    1.способ: тип переменных в массиве + [] + имя массива, пример(int[] arrayName);
    2.способ: тип переменных + имя массива +[], пример(int arrayName[]);
    В массивах примитивных типов хранятся примитивные значения , в массивах ссылочного типа- ссылки на объекты.
    При инициализации массива примитивных типов, значения ячеек по умолчанию имеют 0, при инициализации массивов
    ссылочного типа null.

3)Q:Объясните, что значит клонирование массива, как в Java можно клонировать массив,
   в чем состоит разница в клонировании массивов примитивных и ссылочных типов.
 A:клонироваь массив- значит создать копию данного массива. Для таких операций в java используется метод clone().
   При клонировании массива метод clone() возвращает ссылку на новый массив, который содержит( или ссылается на)
   те же элементы что и исходный массив. При клонировании массива содержащего примитивные типы,
   создается клонированый массив с содержанием таких же значений что и в исходном массиве, но изменения в клонированном
   массиве не повлияют на значения исходного массива. При клонировании массива содержащего ссылки на обЪекты,
   появляется массив с таким же набором ссылок что и исходный, в данном случае при изменении объекта через
   ссылки клонированного массиваБ изменения будут отражены при обращении к тому же объекту и из исходного массива.
   Однако изменения в самом массиве будут влиять только на этот массив.

4)Q:Объясните, что представляет собой двумерных массив в Java, что такое “рваный массив”.
   Как узнать количество строк и количество элементов в каждой строке для “рваного” массива?
 A:Двумерный массив в Java — это массив массивов, то есть в каждой его ячейке находится ссылка на некий массив.
   Но гораздо проще его представить в виде таблицы, у которой задано количество строк (первое измерение)
   и количество столбцов (второе измерение).
   Двумерный массив, у которого все строки имеют равное количество элементов, называется прямоугольным.
   Зубчатый массив в Java - это многомерный массив, содержащий в качестве элементов массивы различных размеров.
   Он также называется «рваным массивом».
   Для определения количества строк используется метод lenght, для определения количества элементов в каждой строке
   используется так же метод lenght к вызваной строке.

5Q:Объясните ситуации, когда в java-коде могут возникнуть следующие исключительные ситуации
   java.lang.ArrayIndexOutOfBoundsException и java.lang.ArrayStoreException.
 A:Исключение java.lang.ArrayIndexOutOfBoundsException возникает вкогда обращаешься к элементам массива с индексом,
   который не является доступным( отрицательный индекс, либо превышающий длину массива).
   Исключение java.lang.ArrayStoreException возникает при попытке сохранить в массив элемент неподхотящего типа.

 6Q:Объясните, зачем при кодировании разделять решаемую задачу на методы.
   Поясните, как вы понимаете выражение: “Один метод не должен выполнять две задачи”.
 A:Решаемую задачу разбивают на методы для более удобного понимания происходящего с объектом и возможностью изменений
   конкретных методов не меняя сути программы. Каждый метод должен выполнять одну задачу для возможности изменений
   конкретной операции не затрагивая остальные.

7Q:Объясните, как в Java передаются параметры в методы, в чем особенность передачи
   в метод значения примитивного типа, а в чем ссылочного.
 A:Для передачи значений параметров метода, примитивные значения необходимого типа либо ссылки на объект
   определенного класса передаются в аргументах метода при его вызове. При передаче примитивных типов
   в метод передается копия значения данной переменной. При передаче ссылки на объект передается копия ссылки
   на данный объект.

8Q:Объясните, как в метод передать массив. И как массив вернуть из метода.
   Можно ли в методе изменить размер переданного массива.
 A:В аргументах вызываемого метода указывается имя существующего массива, либо перечень элементав типа, который указан в
   параметрах метода, в фигурных скобках. Возвращается массив из метода при помощи оператора return.
   Оператор reurn возвращает массив заявленного в методе типа. В копии переданного массива изменить размер нельзя,
   можно только создать новый массив другого размера и вернуть его.

9Q:Поясните, что означает выражение ‘вернуть значение из метода’. Как можно вернуть значение из метода.
   Есть ли разница при возврате значений примитивного и ссылочного типов.
 A:Вернуть значение из метода это значит получить значение заданного методом типа при вызове метода.
   значение возвращается оператором return со значением в конце метода.

10Q:Перечислите известные вам алгоритмы сортировки значений, приведите код, реализующий это алгоритмы.
 A:Пузырьковая сортировка в Java
   Пузырьковая сортировка следует простой логике. Она сравнивает соседние элементы и меняет местами если они
   не отсортированы.
   Пузырьковая сортировка названа таким образом потому, что в этом способе сортировки, меньшие элементы
   постепенно всплывают в верхнюю часть списка.
   Пузырьковая сортировка имеет среднее и наихудшее время равное О(n²), где n количество элементов которое
   нужно отсортировать.
   public class ExampleBubbleSort {

       public static void main(String[] args) {

           int[] num = { 3,6,1,7,2,8,10,4,9,5};
           int n = num.length;
           bubbleSort(num);
           for (int h = 0; h < n; h++)
               System.out.print(num[h]+ " ");
       }

       public static void bubbleSort(int[] numbers) {

           int n = numbers.length;
           int temp = 0;
           for (int i = 0; i < n; i++) {
               for (int j = 1; j < (n - i); j++) {

                   if (numbers[j - 1] > numbers[j]) {
                       //swap elements
                       temp = numbers[j - 1];
                       numbers[j - 1] = numbers[j];
                       numbers[j] = temp;
                   }
               }
           }
       }
   }
   Сортировка методом Шелла
   Дональд Шелл опубликовал первую версию этой сортировки, отсюда и название.
   Эта сортировка является обобщением сортировки вставкой, что позволяет осуществлять обмен элеметов, которые
   находятся далеко друг от друга.
   Она начинается, сравнивая элементы, которые далеки друг от друга, и постепенно уменьшает растояние между
   сравниваемыми элементами.
   Время работы меняется в зависимости от последовательности промежутков используемых для сортировки элементов.
   public class ExampleShellsort {

       public static void main(String[] args) {
           // TODO Auto-generated method stub

           int[] num = { 3,6,1,7,2,8,10,4,9,5};

           shellSort(num);

           for (int h : num)
               System.out.print(h + " ");

       }

       public static void shellSort(int[] numbers){
           int j;
           for( int gap = numbers.length / 2; gap > 0; gap /= 2 ){
               for(int i=gap;i<numbers.length;i++){
                   int temp = numbers[i];
                   for (j = i; j >= gap && numbers[j - gap] > temp; j -= gap)
                   {
                       numbers[j] = numbers[j - gap];
                   }
                   numbers[j] = temp;
               }
           }
       }
   }
   Блочная сортировка (bucket sort)
   Алгоритм блочной сортировки распределяет элементы массива в некоторое число блоков. Это сортировка без сравнения.
   Работает блочная сортировка следующим образом:
   создается массив пустых инициализированных блоков;
   программа обходит оригинальный массив и вставляет каждый элемент в блок;
   каждый блок имеющий по крайней мере один элемент сортируется;
   все элементы вставляются назад в оригинальный массив.
   import java.util.Arrays;

   public class ExampleBucketSort {

       public static void main(String[] args) {

           int[] num = { 3,6,1,7,2,8,10,4,9,5};
           int n = num.length;
           bucketSort(num);
           for (int h = 0; h < n; h++)
               System.out.print(num[h]+ " ");
       }


        public static int[] bucketSort(int[] arr) {
               int i, j;
               int[] bucket = new int[arr.length+1];
               Arrays.fill(bucket, 0);
               for (i = 0; i < arr.length; i++) {
                   bucket[arr[i]]++;
               }

               int k=0;
               for (i = 0; i < bucket.length; i++) {
                   for (j = 0; j<bucket[i]; j++) {
                       arr[k++] = i;
                   }
               }
               return arr;
           }
   }
   Сортировка выбором
   Сортировка выбором представляет собой механизм сортировки, который начинается с поиска наименьшего элемента
   в массиве и размешение его первым.
   Затем находится второй наименьший элемент и размещается вторым, и так до тех пор пока весь массив не отсортируется.
 public static int[]selectionSort(int[]a){
        for(int i=0;i<a.length;i++){
            int pos=i;
            int min=a[i];
            for(int j=i+1;j<a.length;j++){
               if(a[j]<min){
               pos=j;
               min=a[j];
               }
            }
            a[pos]=a[i];
            a[i]=min;
        }
        return a;
    }
Сортировка вставкой
Алгоритм сортировки вставкой просматривает данные в виде двух половинок.
Левая половина отсортированных элементов, правая которые нужно отсортировать.
В каждой итерации, один элемент из правой половины берется и добавляется в левую половину так, что левая половина
по-прежнему остается отсортированной.
Сортировка вставкой сортирует за время О(n²)
private void insertionSort(int[] elements) {
    for (int i = 1; i < elements.length; i++) {
        int key = elements[i];
        int j = i - 1;
        while (j >= 0 && key < elements[j]) {
            elements[j + 1] = elements[j];
            j--;
        }// end while loop
        elements[j + 1] = key;
    }// end for loop
}